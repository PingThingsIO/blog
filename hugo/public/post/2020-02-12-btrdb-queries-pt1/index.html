<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      name="description"
      content="PingThings' PredictiveGrid™ platform offers a time series database purpose built for industrial scale deployments of high rate sensors (1Khz+). It includes all the tools necessary to ingest, store, visualize, analyze, and perform machine learning or deep learning on your data."
    />
    <meta
      name="keywords"
      content="time series, TSDB, data analysis, machine learning, deep learning, AI, IoT, energy, DOE"
    />

    <title>
      NI4AI - National Infrastructure for AI on the Electric Grid
    </title>

    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
    
    <link href="/assets/css/page.css" rel="stylesheet" />
    <link href="/assets/css/style.css" rel="stylesheet" />
    


    
    <link rel="stylesheet" href="/assets/css/page.css">
     

     

   <meta property="og:title" content="Memory Efficient BTrDB Queries: Part 1" />
<meta property="og:description" content="How to leverage the Berkeley Tree to create memory efficient queries" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.ni4ai.org/post/2020-02-12-btrdb-queries-pt1/" />
<meta property="article:published_time" content="2020-02-12T10:20:38-05:00" />
<meta property="article:modified_time" content="2020-02-12T10:20:38-05:00" />
<meta itemprop="name" content="Memory Efficient BTrDB Queries: Part 1">
<meta itemprop="description" content="How to leverage the Berkeley Tree to create memory efficient queries">
<meta itemprop="datePublished" content="2020-02-12T10:20:38-05:00" />
<meta itemprop="dateModified" content="2020-02-12T10:20:38-05:00" />
<meta itemprop="wordCount" content="1436">



<meta itemprop="keywords" content="btrdb,python,data structures,algorithms,analytics," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memory Efficient BTrDB Queries: Part 1"/>
<meta name="twitter:description" content="How to leverage the Berkeley Tree to create memory efficient queries"/>

    
    <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png" />
    <link rel="icon" href="assets/img/favicon.png" />

    
    <meta property="og:title" content="PingThings PredictiveGrid™" />
    <meta
      property="og:description"
      content="PingThings' PredictiveGrid™ platform offers a time series database purpose built for industrial scale deployments of high rate sensors (1Khz+). It includes all the tools necessary to ingest, store, visualize, analyze, and perform machine learning or deep learning on your data."
    />
    <meta
      property="og:image"
      content="https://pingthings.io/assets/img/logo-light.png"
    />
    <meta property="og:url" content="https://pingthings.io/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@pingthingsio" />
    <meta
      name="twitter:title"
      content="A comprehensive platform for data science on petabyte scale sensor data."
    />
    <meta
      name="twitter:description"
      content="PingThings' PredictiveGrid™ platform offers a time series database purpose built for industrial scale deployments of high rate sensors (1Khz+). It includes all the tools necessary to ingest, store, visualize, analyze, and perform machine learning or deep learning on your data."
    />
    <meta
      name="twitter:image"
      content="https://pingthings.io/assets/img/logo-light.png"
    />
  </head>

  <body data-aos-easing="ease" data-aos-duration="1500" data-aos-delay="0" class="">

    
   
  <header>
  <nav
    class="navbar navbar-expand-lg navbar-dark"
    style="top: 0;"
    data-navbar="sticky"
  >
    
    <div class="pl5 pb3 row">
      <div class="col-8 col-lg-2 navbar-left" style="padding-left: 0px;">
        <button class="navbar-toggler" type="button">☰</button>
        <a class="navbar-brand" href="/">
          <span style="font-size: 20px; color: black;">NI4AI Blog</span>
          
        </a>
      </div>
      <section class="col-lg-8 navbar-mobile">
  <nav class="nav nav-navbar mx-auto">
    
    <a class="nav-link" href="/about/" title="About">About</a>
    
    <a class="nav-link" href="/post/" title="Articles">Articles</a>
    
    <a class="nav-link" href="https://ni4ai.org" title="Project Home">
      Project Home
    </a>
  </nav>
</section>

    </div>
    
  </nav>
  <div style="height: 56px;"></div>
</header>


    
  
  <article class="flex-l flex-wrap justify-between pl5 pt5 mw9">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        ARTICLES
      </p>
      <h1 class="f1 athelas mb1">Memory Efficient BTrDB Queries: Part 1</h1>
      
      <time class="f6 mv4 dib tracked" datetime="2020-02-12T10:20:38-05:00">February 12, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p><a href="http://btrdb.io/">The Berkeley Tree Database (BTrDB)</a> provides effective distributed storage of dense scalar-valued telemetry data. It can store data with nanosecond precision, and it supports reading and writing more than 10 million points per second per node. As a result it is an excellent tool for analyzing historical high-frequency (usually 30-240 Hz) sensor readings that produce gigabytes of data an hour.</p>
<p>When working with such large amounts of data, it is important to conduct queries in a manner that efficiently utilizes the main memory of your machine. While the BTrDB API supports streaming raw values and windows over large time ranges, it is often not necessary or wise to do so when most computations can be composed of batches and when such analytics require non-trivial computation time. BTrDB&rsquo;s unique tree structure was designed to support queries at arbitrary levels of time granularity with constant time aggregation. This structure can also be used to compose multiple queries, loading data into a computation on demand, while pruning away unnecessary data before it is retrieved from the database. Conducting queries in this way reduces the amount of the BTrDB tree that needs to be traversed and held in memory, thus greatly improving performance.</p>
<p>In this post we will introduce the concepts needed to understand how to conduct these memory efficient queries. These concepts include tree data structures, depth-first traversal and breadth-first traversal. We will then follow up in our next post to discuss how these concepts can be applied to conduct memory-efficient queries with the BTrDB.</p>
<h2 id="tree-data-structures">Tree Data Structures</h2>
<p>The first step to understanding tree query algorithms is to understand the tree data structure. To simply illustrate this, we can implement a simple tree structure in Python as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>(object):
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A tree node has a label that identifies it as well as children and a single parent.
</span><span style="color:#e6db74">    Any k-ary tree can be constructed using this simple data structure.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> __init__(self, label, children<span style="color:#f92672">=</span>None, parent<span style="color:#f92672">=</span>None):
        self<span style="color:#f92672">.</span>label <span style="color:#f92672">=</span> label
        self<span style="color:#f92672">.</span>parent <span style="color:#f92672">=</span> parent
        self<span style="color:#f92672">.</span>children <span style="color:#f92672">=</span> children <span style="color:#f92672">or</span> []
<span style="color:#960050;background-color:#1e0010">​</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_child</span>(self, label):
        child <span style="color:#f92672">=</span> Node(label, [], self)
        self<span style="color:#f92672">.</span>children<span style="color:#f92672">.</span>append(child)
        <span style="color:#66d9ef">return</span> child
<span style="color:#960050;background-color:#1e0010">​</span>
    <span style="color:#66d9ef">def</span> __iter__(self):
        <span style="color:#66d9ef">for</span> child <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>children:
            <span style="color:#66d9ef">yield</span> child
<span style="color:#960050;background-color:#1e0010">​</span>
    <span style="color:#66d9ef">def</span> __len__(self):
        <span style="color:#66d9ef">return</span> len(self<span style="color:#f92672">.</span>children)
<span style="color:#960050;background-color:#1e0010">​</span>
    <span style="color:#66d9ef">def</span> __str__(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>label
</code></pre></div><p>Trees are constructed with <code>Node</code> objects that have a label, children, and a parent. The first node in the tree is called the <em>root node</em> - it is the only node in the tree that does not have a parent. Nodes with children are called <em>interior nodes</em> because they are in the middle of the tree. Nodes without children are called <em>leaf nodes</em> because they are on the outside of the tree. The size of the tree is the number of nodes and the depth of the tree is the number of connections from the root to the farthest leaf node.</p>
<p>Consider the following example tree with size=11 and depth=3 that we will use throughout the rest of the post:</p>
<p><img src="/media/post/2020-02-12-btrdb-queries-pt1/example_tree.png" alt="An example tree with size=11 and depth=3"></p>
<p>Creating this tree using a Python function is as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">make_tree</span>():
    <span style="color:#75715e"># Create root node and its children</span>
    A <span style="color:#f92672">=</span> Node(<span style="color:#e6db74">&#34;A&#34;</span>)
    B <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;B&#34;</span>)
    C <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;C&#34;</span>)

    <span style="color:#75715e"># Add the second layer of the tree through B and C</span>
    B<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;D&#34;</span>)
    E <span style="color:#f92672">=</span> B<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;E&#34;</span>)
    B<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;F&#34;</span>)
    G <span style="color:#f92672">=</span> C<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;G&#34;</span>)

    <span style="color:#75715e"># Add the third layer of the tree via E and G</span>
    E<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;J&#34;</span>)
    E<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;K&#34;</span>)
    G<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;H&#34;</span>)
    G<span style="color:#f92672">.</span>add_child(<span style="color:#e6db74">&#34;I&#34;</span>)

    <span style="color:#75715e"># Return the root node of the tree</span>
    <span style="color:#66d9ef">return</span> A

tree <span style="color:#f92672">=</span> make_tree()
</code></pre></div><p>To traverse this tree, we will start at the root and then <em>recursively</em> access children. There are two primary methods of traversing trees: depth-first and breadth-first. In our examples using this tree we will consider a method that is designed to apply a function to each node in the tree. The function should return <code>True</code> if the traversal should continue or <code>False</code> if the traversal should stop (<code>break</code>). The most common example is to conduct a search, where we want to find a node that meets a specific criteria, once that criteria is found, we can stop our search.</p>
<h3 id="depth-first">Depth-First</h3>
<p>Depth-first traversal starts at the root and goes as deep to the left of the tree as possible before traversing back up the tree and down again. The goal of depth-first traversal is to access the leaf nodes in the tree as quickly as possible given the structure described above. This kind of traversal is implemented as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">depth_first</span>(root, func):
    <span style="color:#75715e"># If the node has children, traverse down into the chidren</span>
    <span style="color:#66d9ef">if</span> len(root) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">for</span> child <span style="color:#f92672">in</span> root:
            depth_first(child, func)

    <span style="color:#75715e"># Apply the function to the node</span>
    func(root)

<span style="color:#75715e"># Start depth-first traversal with the root of the tree</span>
depth_first(make_tree(), <span style="color:#66d9ef">print</span>)
</code></pre></div><p>The <code>depth_first()</code> function recursively applies a function, <code>func</code> to each node in the tree starting with the lowest left node. It does this by first applying the function to any children the node has, by traversing the children using the depth-first call. If the node does not have children (it is a leaf node) or the function has been applied to all children of the current node, the function is applied. This allows the function to quickly reach the bottom of the tree.</p>
<p>The expected print output from <code>depth_first()</code> is:</p>
<pre><code>D
J
K
E
F
B
H
I
G
C
A
</code></pre><p>Depth-first traversal is commonly used because of its ease of implementation and the fact that it doesn&rsquo;t have book keeping requirements that might require increased memory usage. If the order of applying the function matters, e.g. if you&rsquo;re searching for a value and will stop when you find it, then it is important to consider the path the traversal takes. For example, in BTrDB where moving left to right across the tree means moving increasing time-order, depth-first traversal is the best way to find the <em>earliest</em> example of something in time.</p>
<h3 id="breadth-first">Breadth-First</h3>
<p>Breadth-first traversal prioritizes interior nodes rather than leaf nodes by traversing each level of the tree at a time. Starting at the root node, a breadth-first traversal collects all the children of the current level, then iterates accross them, collecting all of the children at the level below. The collection mechanism requires some extra bookkeeping, though we are still able to implement breadth-first search recursively.</p>
<p>Here is an example of a function that executes breadth-first to similarly apply a function, <code>func</code> to each node in the tree:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">breadth_first</span>(nodes, func):
    <span style="color:#75715e"># Helper to make it easier to pass the root node</span>
    <span style="color:#66d9ef">if</span> isinstance(nodes, Node):
        nodes <span style="color:#f92672">=</span> [nodes]

    <span style="color:#75715e"># Quit if no more nodes</span>
    <span style="color:#66d9ef">if</span> len(nodes) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span>

    <span style="color:#75715e"># Get the current node and apply the function, stopping if it returns False</span>
    current <span style="color:#f92672">=</span> nodes[<span style="color:#ae81ff">0</span>]
    func(current)

    <span style="color:#75715e"># Append the children to the list of nodes to traverse and continue</span>
    <span style="color:#66d9ef">if</span> len(current) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
        nodes <span style="color:#f92672">+=</span> list(current)

    <span style="color:#66d9ef">return</span> breadth_first(nodes[<span style="color:#ae81ff">1</span>:], func)

<span style="color:#75715e"># Start breadth-first traversal with the root of the tree</span>
breadth_first(make_tree(), <span style="color:#66d9ef">print</span>)
</code></pre></div><p>Instead of a single node object, the first argument to the recursive <code>breadth_first()</code> function is a list of nodes. To make passing the root node to the tree easier (the usual place where the traversal starts), the first step of the function is a check to convert a single node into a list of nodes. The recursive stop condition is to check if an empty list has been passed in. Otherwise, the first node in the list is fetched as the current node and the function applied to it. We then collect all of the children of the node and append them to the list, this ensures that the level below the current node is only started after the current level is completed and that traversal of the children in the level below happens in a left to right fashion. We can then continue to recurse on all of the children, omitting the current node from the next call.</p>
<p>The expected printed order of this function is</p>
<pre><code>A
B
C
D
E
F
G
J
K
H
I
</code></pre><p>While breadth-first traversal is a bit trickier to implement, it is important to consider the tree traversal pattern. If you&rsquo;re searching for a value that is in the middle of the tree or to the far right of the tree, then breadth-first traversal could be a far better strategy. In the case of BTrDB, breadth-first traversal allows you to easily traverse all time at different time granularities, collecting statistical information about the values below. If you&rsquo;re looking for the latest window or all windows that meet certain criteria, breadth-first traversal might be the better strategy.</p>
<h2 id="recap">Recap</h2>
<p>In those post we introduced tree data structures as well as the two primary approaches for traversing them. Please stay tuned for Part II, which will detail how to apply these concepts to the BTrDB.</p>
<ul class="pa0">
  
   <li class="list">
     <a href="/tags/btrdb" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">btrdb</a>
   </li>
  
   <li class="list">
     <a href="/tags/python" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">python</a>
   </li>
  
   <li class="list">
     <a href="/tags/data-structures" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">data structures</a>
   </li>
  
   <li class="list">
     <a href="/tags/algorithms" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">algorithms</a>
   </li>
  
   <li class="list">
     <a href="/tags/analytics" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">analytics</a>
   </li>
  
</ul>

<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3"></p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/post/2019-12-12-btrdb-explained/">BTrDB Explained</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/post/2020-02-04-linear-models-overview/">Training General Linear Models with the PredictiveGrid™</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    
<footer class="footer">
  <div class="container">
    <div class="row gap-y align-items-center">
      <div class="col-6 col-lg-3">
        <a href="https://www.pingthings.ai"
          ><img src="/assets/img/logo-dark.png" alt="logo"
        /></a>
      </div>

      <div class="col-6 col-lg-3 text-right order-lg-last">
        <div class="social">
          <a class="social-twitter" href="https://twitter.com/pingthingsio"
            ><i class="fa fa-twitter-square"></i
          ></a>
          <a
            class="social-linkedin"
            href="https://www.linkedin.com/company/pingthings/about/"
            ><i class="fa fa-linkedin-square"></i
          ></a>
        </div>
      </div>

      <div class="col-lg-6 text-center">
        <small>© 2019. All rights reserved.</small>
      </div>
    </div>
  </div>
</footer>


    

<script src="/assets/js/page.js"></script>
<script src="/assets/js/script.js"></script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: {
          equationNumbers: { autoNumber: "AMS" },
          extensions: ["AMSmath.js", "AMSsymbols.js"]
        }
      }
    });
    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });

    MathJax.Hub.Config({
      
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>
  </body>


  </body>
</html>

